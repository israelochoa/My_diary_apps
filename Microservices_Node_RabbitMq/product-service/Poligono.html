<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Image Zoom with Drawing Canvas, Undo and Cut Features</title>
    <style>
        #frame {
            width: auto;
            height: auto;
            overflow: auto;
            border: 1px solid black;
            position: relative;
        }
        #image, #canvas {
            position: absolute;
        }
        #canvas {
            cursor: crosshair;
        }
    </style>
</head>
<body>
    <!--Herramientas de trabajo-->
    <div id="frame">
        
        <canvas id="canvas" width="500" height="500"></canvas>
    </div>
    <br>
    <button onclick="ZoomIn()">Zoom IN</button>
    <button onclick="ZoomOut()">Zoom Out</button>
    <button onclick="toggleDrawing()" id="btnLienzo">Lienzo</button>
    <button onclick="undoLastStep()" id="btnUndo" disabled>Deshacer</button>
    <button onclick="recortarImagen()" id="btnCut" disabled>Recorte</button>
    <button id="btnDownload" onclick="descargarImagen()" disabled>Descargar</button>

    <script>
        
        let canvas = document.getElementById('canvas');
        let ctx = canvas.getContext('2d', { willReadFrequently: true });
        let drawing = false;
        let zoomLevel = 1;
        let points = [];
        let minZoomLevel = 1;
        let maxZoomLevel = 3;
        let polygonClosed = false;

        var imagePath='51.jpeg';
        var image=new Image();
        image.src=imagePath;
        let imageWidthOriginal=0;

        let imageHeightOriginal=0;

        let imageWidth=0;

        let imageHeight= 0;


        
        
        image.onload=function(){
            //Obtener dimensiones de la imagen
            imageWidthOriginal=this.width;
            imageHeightOriginal=this.height;
            imageWidth=imageWidthOriginal/3;
            imageHeight=imageHeightOriginal/3;
            console.log('Dimensiones de la imagen: Ancho=',imageWidth,'px,Alto =',imageHeight,'px');
            //Establecer dimesiones del lienzo
            var canvas = document.getElementById('canvas');
            canvas.width=imageWidth;
            canvas.height=imageHeight;
//Dibujar la imagen en el lienzo
            var ctx=canvas.getContext("2d");
            ctx.drawImage(image,0,0,imageWidth,imageHeight);
            //Establecer dimensiones del contenedor 'frame'
            var frame=document.getElementById('frame');
            frame.style.width=imageWidth+"px";
            frame.style.height=imageHeight+"px";
        }
//Control ZoomIn +
        function ZoomIn() {
            if (zoomLevel < maxZoomLevel) {
                zoomLevel += 0.1;
                scaleImageAndCanvas(zoomLevel);
                //adjustFrameSize();
                console.log("---------------function ZoomIn() . Coordinates:----------------");
                console.log(points);
                console.log("function ZoomIn() :Image size with zoom:", image.width, "x", image.height);
            }
            console.log(" function ZoomIn() : var zoomLevel");
            console.log(zoomLevel)
        }
//Control Zoom -
        function ZoomOut() {
            if (zoomLevel > minZoomLevel) {
                zoomLevel -= 0.1;
                scaleImageAndCanvas(zoomLevel);
                //adjustFrameSize();  
                console.log("---------------function ZoomOut(). Coordinates:---------------");
                console.log(points);
                console.log("function ZoomOut():Image size with zoom:", image.width, "x", image.height);
            }
            console.log(" function ZoomOut(): var zoomLevel");
            console.log(zoomLevel)
        }

//Control button Lienzo
        function toggleDrawing() {
            console.log(" --------------- function toggleDrawing() ---------------");
            drawing = !drawing;
            
            console.log(" function toggleDrawing(): var zoomLevel");
            console.log(zoomLevel)
            if (drawing && !polygonClosed) {
                console.log("  function toggleDrawing(): if (drawing && !polygonClosed)  ");
                console.log("  function toggleDrawing():call addPoint() ");
                canvas.addEventListener('click', addPoint);
            } else {
                console.log("  function toggleDrawing(): else (drawing && !polygonClosed)  ");
                console.log("  function toggleDrawing():call addPoint() ");
                canvas.removeEventListener('click', addPoint);
            }
        }
//Control addPoint with zoom or without
        function addPoint(e) {
            let rect = canvas.getBoundingClientRect();
            //let x = (e.clientX - rect.left) / zoomLevel;
            //let y = (e.clientY - rect.top) / zoomLevel;
            let x = (e.clientX - rect.left) / zoomLevel;
            let y = (e.clientY - rect.top) / zoomLevel;
            console.log("---------------function addPoint(e)---------------:");
            console.log("x = (e.clientX - rect.left) / zoomLevel;");
            console.log(x);
            console.log("y = (e.clientY - rect.top) / zoomLevel;");
            console.log(y);
            console.log("Image size with zoom:", image.width, "x", image.height);
            points.push({ x: x, y: y });
            document.getElementById('btnUndo').disabled = (points==0);
            console.log("function addPoint(e),call drawPolygon():");
            console.log("function addPoint(e),call checkPolygonClosure():");
            drawPolygon();
            checkPolygonClosure();
        }
//Verifica que el poligono no este cerrado, para continuar con la seccion de puntos
        function checkPolygonClosure() {
            console.log(" ---------------function checkPolygonClosure(): var points[i]---------------");
            console.log(points)
            if (points.length > 1 && isCloseToStart(points[0], points[points.length - 1])) {
                polygonClosed = true;
                document.getElementById('btnCut').disabled = false;
                document.getElementById('btnLienzo').disabled = true;
                document.getElementById('btnUndo').disabled = false;
                
            }else if(isCloseToStart(points[0], points[points.length - 1])){
                drawing=false;
                polygonClosed = false;
            }
        }
            
//Verifica que el poligono no este cerrado, para continuar con la seccion de puntos
        function isCloseToStart(start, end) {
            let threshold = 4;
            return Math.abs(start.x - end.x) < threshold && Math.abs(start.y - end.y) < threshold;
        }
//Este funcion une los puntos - Aqui se produce el Dibujo
        function drawPolygon() {
            if (points.length > 1) {
                ctx.beginPath();
                ctx.moveTo(points[0].x * zoomLevel, points[0].y * zoomLevel);
                for (let i = 1; i < points.length; i++) {
                    ctx.lineTo(points[i].x * zoomLevel, points[i].y * zoomLevel);
                }
                if (polygonClosed) {
                    ctx.closePath();
                }
                ctx.stroke();
            }
        }
//Control Button "Deshacer". Permite deshacer un paso del dibujo
        function undoLastStep() {
            if (points.length > 0) {
                points.pop();
             
                document.getElementById('btnCut').disabled = true;
                document.getElementById('btnLienzo').disabled = false;
                document.getElementById('btnUndo').disabled = points.length === 0;
                drawPolygon();
                
            
            console.log("--------------function undoLastStep():------------------")
            console.log(points);
        }
    }
        let originalImage;

  

        function isPointInPolygon(x, y) {
            let inside = false;
            for (let i = 0, j = points.length - 1; i < points.length; j = i++) {
                let xi = points[i].x, yi = points[i].y;
                let xj = points[j].x, yj = points[j].y;

                let intersect = ((yi > y) != (yj > y)) &&
                    (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
                if (intersect) inside = !inside;
            }
            return inside;
        }

        function updateLineWidth() {
            console.log("---------------function updateLineWidth():---------------")
            // Calculate line width based on the current zoom level
            ctx.lineWidth = 1.5* zoomLevel;
        }

        //Esta funcion presenta la imagen mas grande
        function scaleImageAndCanvas(zoom) {
            let newWidth = imageWidth * zoom;
            let newHeight = imageHeight * zoom;
            image.width = newWidth;
            image.height = newHeight;
            canvas.width = newWidth;
            canvas.height = newHeight;
            updateLineWidth();
            // Dibuja la imagen en el lienzo con las nuevas dimensiones
            ctx.drawImage(image, 0, 0, canvas.width, canvas.height);
            drawPolygon();
            
        }
        function adjustInteraction() {
            console.log("---------------function function adjustInteraction():---------------")
            if (polygonClosed) {
                canvas.removeEventListener('click', addPoint);
                document.getElementById('btnCut').disabled = false;
                document.getElementById('btnLienzo').disabled = true;
            } else {
                
                document.getElementById('btnCut').disabled = true;
                document.getElementById('btnLienzo').disabled = false;
            }
        }

        canvas.addEventListener('click', adjustInteraction);

        function recortarImagen() {
            // Coordenadas de los puntos que definen el polÃ­gono de recorte

            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            // Dibujar la imagen original en el canvas
            ctx.drawImage(image, 0, 0, canvas.width, canvas.height);

            // Cambiar la operaciÃ³n de composiciÃ³n global a 'destination-in' para que solo se muestren las partes de la imagen original que se superponen con el prÃ³ximo dibujo
            ctx.globalCompositeOperation = 'destination-in';

            // Dibujar el polÃ­gono de recorte
            ctx.beginPath();
            ctx.moveTo(points[0].x* zoomLevel, points[0].y* zoomLevel);
            for (let i = 1; i < points.length; i++) {
                ctx.lineTo(points[i].x* zoomLevel, points[i].y* zoomLevel);
            }
            ctx.closePath();
            ctx.fill();

            // Cambiar la operaciÃ³n de composiciÃ³n global a 'destination-over' para que los prÃ³ximos dibujos se superpongan a los existentes
            ctx.globalCompositeOperation = 'destination-over';

            // Dibujar un rectÃ¡ngulo negro del mismo tamaÃ±o que la imagen original
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            document.getElementById('btnDownload').disabled=false;
               
        }

        function descargarImagen(){
            // Crear un canvas temporal con las dimensiones originales de la imagen
            let canvasTemporal = document.createElement('canvas');
            canvasTemporal.width = imageWidthOriginal;
            canvasTemporal.height = imageHeightOriginal;
            let ctxTemporal = canvasTemporal.getContext('2d');

            // Dibujar la imagen recortada en el canvas temporal con las dimensiones originales
            ctxTemporal.drawImage(canvas, 0, 0, imageWidthOriginal, imageHeightOriginal);

            // Crear el enlace de descarga con la imagen del canvas temporal
            let enlace = document.createElement('a');
            let imagen = canvasTemporal.toDataURL('image/png');
            enlace.href = imagen;
            enlace.download = 'mi-imagen.png';
            enlace.click();
        }
        
        
    </script>
</body>
</html>
